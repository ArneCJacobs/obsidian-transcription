/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/hello/": {
    /** Hello */
    get: operations["hello_hello__get"];
  };
  "/v1/sbm/inference/prompt_to_frames": {
    /**
     * Prompt To Frames 
     * @deprecated 
     * @description This endpoint will take a prompt and return a list of frames, each frame being a string. The frames will be generated using the OpenAI API.
     */
    post: operations["prompt_to_frames_v1_sbm_inference_prompt_to_frames_post"];
  };
  "/v1/sbm/inference/frames_to_images": {
    /**
     * Frames To Images 
     * @deprecated 
     * @description This method will take a list of frame prompts, stylize them, and return a list of frame images
     */
    post: operations["frames_to_images_v1_sbm_inference_frames_to_images_post"];
  };
  "/v1/sbm/inference/prompt_to_images": {
    /**
     * Prompt To Images 
     * @deprecated 
     * @description This method will take a story prompt and return a list of frame images as well as the story itself
     */
    post: operations["prompt_to_images_v1_sbm_inference_prompt_to_images_post"];
  };
  "/v1/sbm/storyboard/": {
    /**
     * Get Storyboards 
     * @description This endpoint will return a list of all storyboards.
     */
    get: operations["get_storyboards_v1_sbm_storyboard__get"];
    /**
     * Create Storyboard 
     * @description This endpoint will take a story prompt and return a list of frames, each frame being a string frame description and an image URL.
     */
    post: operations["create_storyboard_v1_sbm_storyboard__post"];
  };
  "/v1/sbm/storyboard/{storyboard_id}": {
    /**
     * Get Storyboard 
     * @description This endpoint will take a storyboard id and return the entire storyboard object, with frames and styles and revisions.
     */
    get: operations["get_storyboard_v1_sbm_storyboard__storyboard_id__get"];
    /**
     * Update Storyboard 
     * @description This endpoint will take a storyboard id and style id, and return the entire storyboard object, with frames and styles and revisions.
     */
    post: operations["update_storyboard_v1_sbm_storyboard__storyboard_id__post"];
    /**
     * Delete Storyboard 
     * @description This endpoint will take a storyboard id and delete the entire storyboard object, with frames and styles and revisions.
     */
    delete: operations["delete_storyboard_v1_sbm_storyboard__storyboard_id__delete"];
  };
  "/v1/sbm/storyboard/{storyboard_id}/frames": {
    /**
     * Get Storyboard Frames 
     * @description This endpoint will take a storyboard id optionally a style_id and return the frames associated in a 3D matrix [frame_index][style_revision][frame_revision].
     */
    get: operations["get_storyboard_frames_v1_sbm_storyboard__storyboard_id__frames_get"];
  };
  "/v1/sbm/storyboard/{storyboard_id}/frames/{frame_index}": {
    /**
     * Get Storyboard Frame Index 
     * @description This endpoint will take a storyboard id, frame index, and optionally a style_id and return the frames associated in a 2D matrix [frame_index][style_revision][frame_revision].
     */
    get: operations["get_storyboard_frame_index_v1_sbm_storyboard__storyboard_id__frames__frame_index__get"];
  };
  "/v1/sbm/frames/{frame_id}": {
    /**
     * Get Frame 
     * @description This endpoint will take a frame id and return the frame.
     */
    get: operations["get_frame_v1_sbm_frames__frame_id__get"];
    /**
     * Revise Frame 
     * @description This endpoint will take a storyboard id and frame index, and return the revised frame.
     */
    post: operations["revise_frame_v1_sbm_frames__frame_id__post"];
  };
  "/v1/sbm/styles/": {
    /**
     * Get Styles 
     * @description This method will return a list of all the styles
     */
    get: operations["get_styles_v1_sbm_styles__get"];
    /**
     * Create Or Update Style 
     * @description This method will update a style
     */
    post: operations["create_or_update_style_v1_sbm_styles__post"];
  };
  "/v1/sbm/styles/{style_id}": {
    /**
     * Get Style 
     * @description This method will return a style
     */
    get: operations["get_style_v1_sbm_styles__style_id__get"];
    /**
     * Delete Style 
     * @description This method will delete a style
     */
    delete: operations["delete_style_v1_sbm_styles__style_id__delete"];
  };
  "/v1/scribe/transcriptions": {
    /**
     * Create Transcription 
     * @description This method will create a transcription job from a file URL or return a presigned URL to upload an audio file to
     */
    post: operations["create_transcription_v1_scribe_transcriptions_post"];
  };
  "/v1/scribe/transcriptions/{transcription_id}": {
    /**
     * Get Transcription 
     * @description Get the transcription job status and results
     */
    get: operations["get_transcription_v1_scribe_transcriptions__transcription_id__get"];
  };
  "/aws/s3": {
    /** S3 Event Handler */
    put: operations["s3_event_handler_aws_s3_put"];
    /** S3 Event Handler */
    post: operations["s3_event_handler_aws_s3_post"];
    /** S3 Event Handler */
    delete: operations["s3_event_handler_aws_s3_delete"];
  };
  "/aws/sqs": {
    /** Sqs Event Handler */
    post: operations["sqs_event_handler_aws_sqs_post"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** CreateStoryboardRequest */
    CreateStoryboardRequest: {
      /** Original Prompt */
      original_prompt: string;
      /** Frame Count */
      frame_count: number;
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id: string;
      /**
       * User Id 
       * Format: uuid4
       */
      user_id?: string;
    };
    /** CreateTranscriptionRequest */
    CreateTranscriptionRequest: {
      /**
       * Url 
       * Format: uri 
       * @description The url of the audio file to be transcribed. If this is not provided, the audio file must be uploaded via the S3 presigned url 
       * @example https://storage.googleapis.com/gtv-videos-bucket/sample/TearsOfSteel.mp4
       */
      url?: string;
    };
    /** CreateTranscriptionResponse */
    CreateTranscriptionResponse: {
      /**
       * Upload Request 
       * @description The request details to upload the audio file
       */
      upload_request?: Record<string, never>;
      /**
       * Transcription Url 
       * Format: uri 
       * @description The url to request the transcription job status and results
       */
      transcription_url: string;
      /**
       * Transcription 
       * @description The transcription job
       */
      transcription: components["schemas"]["Transcription"];
    };
    /**
     * Frame 
     * @description Full Frame Model, with the fields required to place within a storyboard
     */
    Frame: {
      /** Prompt */
      prompt: string;
      /**
       * Image Url 
       * Format: uri
       */
      image_url: string;
      /**
       * Args 
       * @description The arguments used to generate the frame
       */
      args?: Record<string, never>;
      /**
       * @description The model used to generate the frame 
       * @default dall_e
       */
      model?: components["schemas"]["ImageGeneratorModel"];
      /**
       * Style Id 
       * @description The style id used to generate the frame
       */
      style_id: string;
      /** Frame Index */
      frame_index: number;
      /**
       * Frame Id 
       * @description The frame id, in the following format: (storyboard_id)_(index)_(style_revision)_(frame_revision)
       */
      frame_id: string;
      /**
       * Storyboard Id 
       * @description The storyboard id, a hex string of length 7 (14 characters)
       */
      storyboard_id: string;
      /**
       * Frame Revision 
       * @description The revision of the frame, incremented when the frame is updated 
       * @default 0
       */
      frame_revision?: number;
      /** Style Revision */
      style_revision: number;
    };
    /**
     * FrameMinimal 
     * @description Frame Model, not including the fields required to place within a storyboard
     */
    FrameMinimal: {
      /** Prompt */
      prompt: string;
      /**
       * Image Url 
       * Format: uri
       */
      image_url: string;
      /**
       * Args 
       * @description The arguments used to generate the frame
       */
      args?: Record<string, never>;
      /**
       * @description The model used to generate the frame 
       * @default dall_e
       */
      model?: components["schemas"]["ImageGeneratorModel"];
      /**
       * Style Id 
       * @description The style id used to generate the frame
       */
      style_id: string;
      /** Frame Index */
      frame_index: number;
    };
    /** FramesToImagesRequest */
    FramesToImagesRequest: {
      /** Prompts */
      prompts: (string)[];
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id?: string;
      /** @default dall_e */
      backend?: components["schemas"]["ImageGeneratorModel"];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: (components["schemas"]["ValidationError"])[];
    };
    /**
     * ImageGeneratorModel 
     * @description An enumeration. 
     * @enum {string}
     */
    ImageGeneratorModel: "replicate_sd_2" | "dall_e";
    /** PromptToFramesRequest */
    PromptToFramesRequest: {
      /** Prompt */
      prompt: string;
      /** Frame Count */
      frame_count: number;
      /**
       * Max Tokens 
       * @default 256
       */
      max_tokens?: number;
      /**
       * Temperature 
       * @default 0.7
       */
      temperature?: number;
      /**
       * Top P 
       * @default 1
       */
      top_p?: number;
      /**
       * Frequency Penalty 
       * @default 0
       */
      frequency_penalty?: number;
      /**
       * Presence Penalty 
       * @default 0
       */
      presence_penalty?: number;
    };
    /** PromptToFramesResponse */
    PromptToFramesResponse: {
      /** Frames */
      frames: (string)[];
      /** Llm Response */
      llm_response: Record<string, never>;
    };
    /** PromptToImagesRequest */
    PromptToImagesRequest: {
      /** Prompt */
      prompt: string;
      /** Frame Count */
      frame_count: number;
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id?: string;
      /** @default dall_e */
      backend?: components["schemas"]["ImageGeneratorModel"];
    };
    /** PromptToImagesResponse */
    PromptToImagesResponse: {
      /** Frames */
      frames: (components["schemas"]["FrameMinimal"])[];
      llm_response: components["schemas"]["PromptToFramesResponse"];
    };
    /** ReviseFrameRequest */
    ReviseFrameRequest: {
      /**
       * Prompt 
       * @description The prompt for the frame, should be a single sentence
       */
      prompt: string;
    };
    /**
     * Storyboard 
     * @description Style Model, contains a prompt for style generation and a list of supported models
     */
    Storyboard: {
      /**
       * Storyboard Id 
       * @description The storyboard id, a hex string of length 7 (14 characters)
       */
      storyboard_id?: string;
      /**
       * User Id 
       * Format: uuid4
       */
      user_id: string;
      /**
       * Name 
       * @description The name of the storyboard
       */
      name?: string;
      /**
       * Description 
       * @description The description of the storyboard
       */
      description?: string;
      /**
       * Public 
       * @description If true, the storyboard is public 
       * @default false
       */
      public?: boolean;
      /**
       * @description The status of the storyboard 
       * @default pending
       */
      status?: components["schemas"]["StoryboardStatus"];
      /**
       * Original Prompt 
       * @description The original prompt for the storyboard
       */
      original_prompt: string;
      /**
       * Frames 
       * @description The frames in the storyboard, each frame has properties for the frame index, the style revision, and the frame revision
       */
      frames?: (components["schemas"]["Frame"])[];
      /**
       * Style Revisions 
       * @description Each item is the style id used to generate the corresponding revision of the storyboard
       */
      style_revisions?: (components["schemas"]["Style"])[];
      /**
       * Frame Count 
       * @description The number of frames in the storyboard
       */
      frame_count: number;
      /**
       * Total Frames 
       * @description The total number of frames in the storyboard, including revisions 
       * @default 0
       */
      total_frames?: number;
      /**
       * Created 
       * Format: date-time 
       * @description The datetime the storyboard was created
       */
      created?: string;
      /**
       * Updated 
       * Format: date-time 
       * @description The datetime the storyboard was last updated
       */
      updated?: string;
    };
    /**
     * StoryboardStatus 
     * @description The status of the storyboard  
     * @enum {string}
     */
    StoryboardStatus: "pending" | "processing" | "complete" | "failed";
    /**
     * Style 
     * @description Style Model, contains a prompt for style generation and a list of supported models
     */
    Style: {
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id?: string;
      /**
       * User Id 
       * Format: uuid4
       */
      user_id: string;
      /**
       * Name 
       * @description The name of the style
       */
      name: string;
      /**
       * Description 
       * @description The description of the style
       */
      description?: string;
      /**
       * Style Prompt 
       * @description The prompt for style generation. Must contain the token 'ge_replace_me' to mark where the prompt goes
       */
      style_prompt: string;
      /**
       * Negative Prompt 
       * @description The negative prompt for style generation.
       */
      negative_prompt?: string;
      /** @description If None, all models are supported */
      supported_models?: (components["schemas"]["ImageGeneratorModel"])[];
      /**
       * Public 
       * @description If true, the style is public and can be used by anyone 
       * @default false
       */
      public?: boolean;
      /**
       * Preset 
       * @description If true, the style is a preset and cannot be deleted 
       * @default false
       */
      preset?: boolean;
      /**
       * Preview 
       * Format: uri 
       * @description The url to the preview image for the style
       */
      preview?: string;
      /**
       * Deleted 
       * @description If true, the style is soft deleted and cannot be used 
       * @default false
       */
      deleted?: boolean;
    };
    /**
     * StyleModelRequest 
     * @description All we are doing here is overriding the id field to be optional, since it can be inferred from the request
     */
    StyleModelRequest: {
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id?: string;
      /**
       * User Id 
       * Format: uuid4
       */
      user_id?: string;
      /**
       * Name 
       * @description The name of the style
       */
      name: string;
      /**
       * Description 
       * @description The description of the style
       */
      description?: string;
      /**
       * Style Prompt 
       * @description The prompt for style generation. Must contain the token 'ge_replace_me' to mark where the prompt goes
       */
      style_prompt: string;
      /**
       * Negative Prompt 
       * @description The negative prompt for style generation.
       */
      negative_prompt?: string;
      /** @description If None, all models are supported */
      supported_models?: (components["schemas"]["ImageGeneratorModel"])[];
      /**
       * Public 
       * @description If true, the style is public and can be used by anyone 
       * @default false
       */
      public?: boolean;
      /**
       * Preset 
       * @description If true, the style is a preset and cannot be deleted 
       * @default false
       */
      preset?: boolean;
      /**
       * Preview 
       * Format: uri 
       * @description The url to the preview image for the style
       */
      preview?: string;
      /**
       * Deleted 
       * @description If true, the style is soft deleted and cannot be used 
       * @default false
       */
      deleted?: boolean;
    };
    /**
     * Transcription 
     * @description Transcription Model
     */
    Transcription: {
      /**
       * Transcription Id 
       * @description Unique ID for the transcription
       */
      transcription_id?: string;
      /**
       * User Id 
       * Format: uuid4
       */
      user_id: string;
      /**
       * Created 
       * Format: date-time 
       * @description Time the transcription was created
       */
      created?: string;
      /**
       * Updated 
       * Format: date-time 
       * @description Time the transcription was last updated
       */
      updated?: string;
      /**
       * @description Current status of the transcription 
       * @default pending
       */
      status?: components["schemas"]["TranscriptionStatus"];
      /**
       * Orphaned 
       * @description Whether the transcription has orphaned files in S3 
       * @default false
       */
      orphaned?: boolean;
      /**
       * Error Message 
       * @description Error message if the transcription failed 
       * @example File is not a valid audio or video file
       */
      error_message?: string;
      /**
       * File Ffprobe 
       * @description FFProbe output for the file
       */
      file_ffprobe?: Record<string, never>;
      /**
       * File Type 
       * @description Mimetype of file 
       * @example audio/webm
       */
      file_type?: string;
      /**
       * Url 
       * Format: uri 
       * @description URL of the file 
       * @example https://example.com/file.mp3
       */
      url?: string;
      /**
       * Duration Seconds 
       * @description Duration of the file in seconds 
       * @example 60
       */
      duration_seconds?: number;
      /**
       * Validated 
       * @description Whether the file has been validated 
       * @default false
       */
      validated?: boolean;
      /**
       * Uploaded 
       * @description Whether the file has been uploaded to S3 
       * @default false
       */
      uploaded?: boolean;
      /**
       * Transcoded 
       * @description Whether the file has been transcoded 
       * @default false
       */
      transcoded?: boolean;
      /**
       * Transcribed 
       * @description Whether the file has been transcribed 
       * @default false
       */
      transcribed?: boolean;
      /**
       * @description Model used for transcription 
       * @example openai/whisper-base
       */
      transcription_model?: components["schemas"]["TranscriptionInferenceModel"];
      /**
       * @description Source of the transcription model 
       * @example huggingface
       */
      transcription_backend?: components["schemas"]["TranscriptionInferenceBackend"];
      /**
       * Transcription Result Json 
       * @description Transcription result from the model
       */
      transcription_result_json?: Record<string, never>;
      /**
       * Transcription Result 
       * @description Timestamped transcription result from the model
       */
      transcription_result?: (components["schemas"]["TranscriptionResultSegment"])[];
      /**
       * Transcription Text 
       * @description Transcription text 
       * @example Hello world
       */
      transcription_text?: string;
    };
    /**
     * TranscriptionInferenceBackend 
     * @description An enumeration. 
     * @enum {unknown}
     */
    TranscriptionInferenceBackend: "huggingface" | "whisper.cpp" | "banana" | "replicate";
    /**
     * TranscriptionInferenceModel 
     * @description An enumeration. 
     * @enum {unknown}
     */
    TranscriptionInferenceModel: "openai/whisper-tiny" | "openai/whisper-tiny.en" | "openai/whisper-small" | "openai/whisper-small.en" | "openai/whisper-base" | "openai/whisper-base.en" | "openai/whisper-medium" | "openai/whisper-medium.en" | "openai/whisper-large";
    /** TranscriptionResultSegment */
    TranscriptionResultSegment: {
      /**
       * Start 
       * @description Start time of the segment (seconds)
       */
      start: number;
      /**
       * End 
       * @description End time of the segment (seconds)
       */
      end: number;
      /**
       * Text 
       * @description Text of the segment
       */
      text: string;
      /**
       * Seek 
       * @description Seek time of the segment (milliseconds)
       */
      seek: number;
      /**
       * No Speech Prob 
       * @description Probability that the segment is not speech
       */
      no_speech_prob: number;
    };
    /**
     * TranscriptionStatus 
     * @description An enumeration. 
     * @enum {unknown}
     */
    TranscriptionStatus: "pending" | "uploading" | "uploaded" | "validating" | "validated" | "transcoding" | "transcoded" | "transcribing" | "complete" | "validation_failed" | "failed";
    /** UpdateStoryboardRequest */
    UpdateStoryboardRequest: {
      /**
       * Style Id 
       * @description The style id, a random hex string of length 7 (14 characters)
       */
      style_id?: string;
      /**
       * Name 
       * @description The name of the storyboard
       */
      name?: string;
      /**
       * Description 
       * @description The description of the storyboard
       */
      description?: string;
      /**
       * Public 
       * @description If true, the storyboard is public
       */
      public?: boolean;
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  hello_hello__get: {
    /** Hello */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  prompt_to_frames_v1_sbm_inference_prompt_to_frames_post: {
    /**
     * Prompt To Frames 
     * @deprecated 
     * @description This endpoint will take a prompt and return a list of frames, each frame being a string. The frames will be generated using the OpenAI API.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PromptToFramesRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PromptToFramesResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  frames_to_images_v1_sbm_inference_frames_to_images_post: {
    /**
     * Frames To Images 
     * @deprecated 
     * @description This method will take a list of frame prompts, stylize them, and return a list of frame images
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["FramesToImagesRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["FrameMinimal"])[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  prompt_to_images_v1_sbm_inference_prompt_to_images_post: {
    /**
     * Prompt To Images 
     * @deprecated 
     * @description This method will take a story prompt and return a list of frame images as well as the story itself
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PromptToImagesRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["PromptToImagesResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_storyboards_v1_sbm_storyboard__get: {
    /**
     * Get Storyboards 
     * @description This endpoint will return a list of all storyboards.
     */
    parameters?: {
      query?: {
        user_id?: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["Storyboard"])[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  create_storyboard_v1_sbm_storyboard__post: {
    /**
     * Create Storyboard 
     * @description This endpoint will take a story prompt and return a list of frames, each frame being a string frame description and an image URL.
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateStoryboardRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Storyboard"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_storyboard_v1_sbm_storyboard__storyboard_id__get: {
    /**
     * Get Storyboard 
     * @description This endpoint will take a storyboard id and return the entire storyboard object, with frames and styles and revisions.
     */
    parameters: {
      path: {
        storyboard_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Storyboard"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  update_storyboard_v1_sbm_storyboard__storyboard_id__post: {
    /**
     * Update Storyboard 
     * @description This endpoint will take a storyboard id and style id, and return the entire storyboard object, with frames and styles and revisions.
     */
    parameters: {
      path: {
        storyboard_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateStoryboardRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Storyboard"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  delete_storyboard_v1_sbm_storyboard__storyboard_id__delete: {
    /**
     * Delete Storyboard 
     * @description This endpoint will take a storyboard id and delete the entire storyboard object, with frames and styles and revisions.
     */
    parameters: {
      path: {
        storyboard_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_storyboard_frames_v1_sbm_storyboard__storyboard_id__frames_get: {
    /**
     * Get Storyboard Frames 
     * @description This endpoint will take a storyboard id optionally a style_id and return the frames associated in a 3D matrix [frame_index][style_revision][frame_revision].
     */
    parameters: {
      query?: {
        style_id?: string;
      };
      path: {
        storyboard_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["Frame"])[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_storyboard_frame_index_v1_sbm_storyboard__storyboard_id__frames__frame_index__get: {
    /**
     * Get Storyboard Frame Index 
     * @description This endpoint will take a storyboard id, frame index, and optionally a style_id and return the frames associated in a 2D matrix [frame_index][style_revision][frame_revision].
     */
    parameters: {
      query?: {
        style_id?: string;
      };
      path: {
        storyboard_id: string;
        frame_index: number;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["Frame"])[];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_frame_v1_sbm_frames__frame_id__get: {
    /**
     * Get Frame 
     * @description This endpoint will take a frame id and return the frame.
     */
    parameters: {
      path: {
        frame_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Frame"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  revise_frame_v1_sbm_frames__frame_id__post: {
    /**
     * Revise Frame 
     * @description This endpoint will take a storyboard id and frame index, and return the revised frame.
     */
    parameters: {
      path: {
        frame_id: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ReviseFrameRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Frame"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_styles_v1_sbm_styles__get: {
    /**
     * Get Styles 
     * @description This method will return a list of all the styles
     */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": (components["schemas"]["Style"])[];
        };
      };
    };
  };
  create_or_update_style_v1_sbm_styles__post: {
    /**
     * Create Or Update Style 
     * @description This method will update a style
     */
    requestBody: {
      content: {
        "application/json": components["schemas"]["StyleModelRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Style"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_style_v1_sbm_styles__style_id__get: {
    /**
     * Get Style 
     * @description This method will return a style
     */
    parameters: {
      path: {
        style_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Style"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  delete_style_v1_sbm_styles__style_id__delete: {
    /**
     * Delete Style 
     * @description This method will delete a style
     */
    parameters: {
      path: {
        style_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": boolean;
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  create_transcription_v1_scribe_transcriptions_post: {
    /**
     * Create Transcription 
     * @description This method will create a transcription job from a file URL or return a presigned URL to upload an audio file to
     */
    requestBody?: {
      content: {
        "application/json": components["schemas"]["CreateTranscriptionRequest"];
      };
    };
    responses: {
      /** @description Successful Response */
      201: {
        content: {
          "application/json": components["schemas"]["CreateTranscriptionResponse"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  get_transcription_v1_scribe_transcriptions__transcription_id__get: {
    /**
     * Get Transcription 
     * @description Get the transcription job status and results
     */
    parameters: {
      path: {
        transcription_id: string;
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["Transcription"];
        };
      };
      /** @description Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  s3_event_handler_aws_s3_put: {
    /** S3 Event Handler */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  s3_event_handler_aws_s3_post: {
    /** S3 Event Handler */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  s3_event_handler_aws_s3_delete: {
    /** S3 Event Handler */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
  sqs_event_handler_aws_sqs_post: {
    /** Sqs Event Handler */
    responses: {
      /** @description Successful Response */
      200: {
        content: {
          "application/json": Record<string, never>;
        };
      };
    };
  };
}
